#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        // esp_err_t err = esp_now_send_blocking(
        //                     peerInfo.peer_addr, 
        //                     (uint8_t*)txString.c_str(), 
        //                     txString.length(), 
        //                     &sent, 10000UL);
        Serial.println(txString);
        sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        // Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74#include "SPIFFS.h"
#include "WiFi.h"
#include "freertos/freeRTOS.h"
#include "freertos/task.h"
#include <Arduino.h>
#include "esp_private/wifi.h"
#include <esp_now.h>

static esp_now_peer_info_t peerInfo;

// PMK and LMK keys
static const char* PMK_KEY_STR = "Never Gonna Give";
static const char* LMK_KEY_STR = "dewe dewe dewe d";

#define PEER_MAC_ADDR "FC:F5:C4:01:00:74"
#ifndef PEER_MAC_ADDR
#define PEER_MAC_ADDR "24:0A:C4:59:D3:7C"
#endif

typedef struct {
    uint32_t codes[2];
    uint8_t data[240];
} packet_t;

static String txString;
static String rxString;

static int sent_status = -1;

static bool txReady = false;
static bool rxReady = false;
static const size_t max_txLen = sizeof(packet_t::data);
static const size_t info_len = sizeof(packet_t) - sizeof(packet_t::data);


#define CPS_BUF_SIZE   20
#define CPS_UPDATE_FRQ 10

static uint32_t counters[CPS_BUF_SIZE];
static uint32_t current = 0;
static uint32_t last    = 0;

static uint32_t txAckCode = 0U;
static bool recv_lock = false;

#define millis64() (esp_timer_get_time() / 1000ULL)


void updateCPS(void* param) {
    last = millis() / 100;

    while (true) {
        unsigned long now = millis() / 100;
        while (now - last >= 1) {
            ++last;
            current = (current + 1) % CPS_BUF_SIZE;
            counters[current] = 0;
        }
        delay(50);
    }
    vTaskDelete(NULL);
}

static inline void mousePressed(int n = 1) {
    counters[current] += n;
}

void average(void* param) {
    float avg;
    while (true) {
        uint32_t sum = 0;
        for (int i = 0; i < CPS_BUF_SIZE; ++i) {
            sum += counters[i];
        }
        float average_cps = (float)sum * CPS_UPDATE_FRQ / CPS_BUF_SIZE;
        if (avg != average_cps) {
            Serial.println(average_cps);
            avg = average_cps;
        }
        delay(1000 / CPS_UPDATE_FRQ);
    }
    vTaskDelete(NULL);
}

bool mac_is_configured(uint8_t* mac) {
    for (size_t i = 0; i < 6; i++) {
        if (mac[i] != 0xff) return true;
    }
    return false;
}

/**
 * @brief Get a Mac Address array from a string
 *
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param str mac address string
 * @param buf_mac_addr a uint8_t[6] buffer
 * @return true if successful
 * @return false if format incorrect, original mac address remains unchanged
 */
bool getMacAddr(const char* str, uint8_t* buf_mac_addr) {
    uint8_t mac_addr_tmp[6] = {0}, mac_addr_filled = 0;
    for (const char* i = str; *i != '\0' && mac_addr_filled < 12U; i++) {
        const char ch = *i;
        if (ch == ':') continue;
        uint8_t tmpval = 0U;
        if (ch >= '0' && ch <= '9') {
            tmpval = (uint8_t)(ch - '0');
        } else if (ch >= 'a' && ch <= 'f') {
            tmpval = (uint8_t)(ch - 'a' + 10);
        } else if (ch >= 'A' && ch <= 'F') {
            tmpval = (uint8_t)(ch - 'A' + 10);
        }
        tmpval &= 0x0fU;
        tmpval <<= (4U * (!(mac_addr_filled & 1U)));
        mac_addr_tmp[mac_addr_filled / 2U] |= tmpval;
        mac_addr_filled++;
    }
    if (mac_addr_filled != 12U) return false;
    memcpy(buf_mac_addr, mac_addr_tmp, 6U);
    return true;
}

/**
 * @brief Get the string representation of a MAC address
 * @warning does not check for validity of the
 *          MAC address array
 * Converts String "24:0a:C4:59:D3:7C"
 * to array uint8_t[6] {0x24, 0x0A, 0xC4, 0x59, 0xD3, 0x7C}
 *
 * @param buf a uint8_t[6] buffer containing the MAC address
 * @return String (Mac address with ':' separator)
 */
String getMacString(const uint8_t* buf) {
    String tmp;
    const char symbols[] = "0123456789ABCDEF";
    for (int i = 0; i < 6; i++) {
        if (i > 0) tmp += ':';
        tmp += symbols[(buf[i] >> 4U) & 0x0fU];
        tmp += symbols[buf[i] & 0x0fU];
    }
    return tmp;
}

/**
 * @brief get string task from terminal
 *        and append it to global string 'txString'
 *
 */
void getString(void* param) {
    while (true) {
        if (!digitalRead(19)) {
            if (txReady)
                continue;
            if (!txString.isEmpty()) {
                Serial.println();
                txReady = true;
            }
        } 
        if (Serial.available()) {
            if (txReady)
                continue;
            char c = Serial.read();
            if (c == '\b' && !txString.isEmpty()) {
                Serial.write("\b \b");
                txString.remove(txString.length() - 1);
            } else {
                Serial.write(c);
                txString += c;
            }
            if (millis64() % 10 == 0) vTaskDelay(1);
        } else
            vTaskDelay(10);
    }
    vTaskDelete(NULL);
}

uint32_t data_rng = 0UL;


/**
 * @brief ESP_NOW packet sent callback
 *
 * @param mac_addr address of the peer device
 * @param status send status
 */
void onDataSent(const uint8_t* mac_addr, esp_now_send_status_t status) {

    if (status != ESP_NOW_SEND_SUCCESS)
        Serial.println("[ESP_NOW]: Transmission ERROR");

    // wait for global status to reset before setting a new status
    while (sent_status != -1)
        vTaskDelay(1);
    sent_status = status;
}

esp_err_t esp_now_send_packet_blocking(const uint8_t* peer_addr, const uint8_t* data,
                                size_t len, uint32_t timeout) {
    static bool lock = false;
    int64_t time = millis64();
    while (lock)
        vTaskDelay(1);
    lock = true;
    do {
        sent_status = -1;
        esp_err_t err_send = esp_now_send(peer_addr, data, len);
        while (sent_status == -1)
            vTaskDelay(1);
    } while (sent_status != 0 && (millis64() - time) < timeout);
    lock = false;
    return sent_status;
}

esp_err_t esp_now_send_blocking(const uint8_t* peer_addr, 
            const uint8_t* data, size_t len, 
            size_t* transmitted, uint32_t timeout) {
    size_t i = 0;
    int64_t resend_timeout = millis64();
    for (; i < len;) {
        int txLen = ((len - i) > max_txLen) ? max_txLen : (len - i);
        packet_t packet;
        packet.codes[0] = (1U << (i != 0)); // packet start / continue
        packet.codes[0] |= ((uint8_t)(txLen != max_txLen)) << 2U; // packet end
        // packet rng
        data_rng = i + 1UL;
        packet.codes[1] = data_rng;
        memcpy(&packet.data[0], data + i, txLen);
        while (recv_lock) 
            vTaskDelay(1);
        esp_err_t err = esp_now_send_packet_blocking(
            peer_addr, (uint8_t*)&packet, txLen + info_len, 1000UL);
        if (err != ESP_OK) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Tx ERROR, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        int64_t ack_timeout = millis64();
        while (data_rng != 0UL && (millis64() - ack_timeout < 50UL))
            vTaskDelay(1);
        if (data_rng != 0U) {
            if (millis64() - resend_timeout < timeout) {
                Serial.println("Rx Error, Resending packet");
                continue;
            }
            else return ESP_ERR_TIMEOUT;
        }
        mousePressed(txLen);
        resend_timeout = millis64();
        i += txLen;
        *transmitted = i;
    }
    return ESP_OK;
}


/**
 * @brief ESP_NOW packet received callback
 *
 * @param mac sender mac address
 * @param incomingData buffer of received data
 * @param len received data length
 */
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    
    static uint32_t prevRNG = 0UL;
    while (recv_lock)
        vTaskDelay(1);
    recv_lock = true;

    packet_t* packet = (packet_t*)incomingData;
    if (packet->codes[0] == 0U) {
        if (data_rng == packet->codes[1])
            data_rng = 0U;
        recv_lock = false;
        return;
    }


    while (rxReady)
        vTaskDelay(1);
    if (packet->codes[0] & 1U) {
        rxString.clear();
        prevRNG = 0UL;
    }
    if (packet->codes[1] != prevRNG) {
        for (int i = 0; i < len - info_len; i++) {
            rxString += (char)packet->data[i];
        }
        prevRNG = packet->codes[1];
    }
    if (packet->codes[0] & 4U) {
        rxReady = true;
    }
    recv_lock = false;
    txAckCode = packet->codes[1];
}



void OnDataAck(void* param) {
    while (true) {
        if (txAckCode != 0U) {
            if (recv_lock) continue;
            esp_now_unregister_recv_cb();
            vTaskDelay(1);
            uint32_t data[2] = {0UL, txAckCode};
            esp_now_send_packet_blocking(
                peerInfo.peer_addr, (uint8_t*)data, 
                sizeof(data), 1000UL);
            txAckCode = 0UL;
            esp_now_register_recv_cb(OnDataRecv);
        } else vTaskDelay(1);
    }
    vTaskDelete(NULL);
}

void setup() {

    // set uart rx buffer to 16kb
    log_d("Total heap: %d", ESP.getHeapSize());
    log_d("Free heap: %d", ESP.getFreeHeap());
    log_d("Total PSRAM: %d", ESP.getPsramSize());
    log_d("Free PSRAM: %d", ESP.getFreePsram());
    delay(1000);
    Serial.setRxBufferSize(16384UL);
    Serial.begin(115200);

    Serial.println(ESP.getPsramSize() - ESP.getFreePsram());

    pinMode(2, OUTPUT);
    pinMode(19, INPUT_PULLUP);
    xTaskCreate(getString, "terminal", 4096, NULL, 1, NULL);
    xTaskCreate(OnDataAck, "onDataAck", 4096, NULL, 1, NULL);
    
    // CPS Counter Tasks
    xTaskCreate(updateCPS, "update", 4096, NULL, 1, NULL);
    xTaskCreate(average, "average", 4096, NULL, 1, NULL);

    WiFi.mode(WIFI_MODE_STA);
    Serial.println(WiFi.getTxPower());
    ESP_ERROR_CHECK(esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_2M_L));
    Serial.println("This Device: " + WiFi.macAddress());

    while (esp_now_init() != ESP_OK) {
        Serial.println("[ESP_NOW]: Init ERROR");
        Serial.println("[ESP_NOW]: Retrying");
        vTaskDelay(1000);
    }

    esp_now_set_pmk((const uint8_t*)PMK_KEY_STR);
    memcpy(peerInfo.lmk, LMK_KEY_STR, 16);

    esp_now_register_send_cb(onDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    getMacAddr(PEER_MAC_ADDR, peerInfo.peer_addr);
    // getMacAddr("FF:FF:FF:FF:FF:FF", peerInfo.peer_addr);
    peerInfo.channel = 0U;
    peerInfo.encrypt = true;
    // peerInfo.encrypt = false;

    // while (!mac_is_configured(peerInfo.peer_addr)) {
    //     Serial.println("peer MAC is not configured");
    //     vTaskDelay(1000);
    // }
    while (esp_now_add_peer(&peerInfo) != ESP_OK) {
        Serial.println("Failed to add peer");
        vTaskDelay(1000);
    }
}


void loop() {

    if (txReady) {
        bool success = true;
        size_t sent = 0UL;
        int64_t time = esp_timer_get_time();
        esp_err_t err = esp_now_send_blocking(
                            peerInfo.peer_addr, 
                            (uint8_t*)txString.c_str(), 
                            txString.length(), 
                            &sent, 10000UL);
        // Serial.println(txString);
        // sent = txString.length();
        time = esp_timer_get_time() - time;
        if (time != 0) {
            int64_t n_sent = sent;
            n_sent *= 1000000LL;
            double speed = (double)n_sent / time;
            Serial.println("Speed: " + String(speed));
        }
        txString.clear();
        txReady = false;
        Serial.print((err != ESP_OK) ? "Transmission Failed, " : "Transmission Success, ");
        Serial.println("Sent " + String(sent) + " bytes");

    } else if (rxReady) {
        Serial.println("from " + getMacString(peerInfo.peer_addr));
        Serial.println(rxString);
        Serial.println("Received " + String(rxString.length()) + " bytes");
        rxString.clear();
        rxReady = false;
    } else
        vTaskDelay(100);
}
//3C:71:BF:F1:40:B4
//FC:F5:C4:01:00:74